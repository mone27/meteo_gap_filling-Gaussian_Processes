# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_Imputation.ipynb.

# %% auto 0
__all__ = ['GPFAFakeData', 'GPFAImputation']

# %% ../nbs/02_Imputation.ipynb 7
class GPFAFakeData:
    def __init__(self,
                    n_features: int,
                    n_obs: int,
                    latent_func = torch.sin, # Functions used to generate the true latent
                    noise_std = .2,
                    Lambda = None
                ):
        
        self.n_features, self.n_obs = n_features, n_obs
        self.T = torch.arange(n_obs)
        
        self.latent = latent_func(self.T)
        
        self.Lambda = torch.tensor(Lambda).reshape(n_features, 1) if Lambda is not None else torch.rand(n_features, 1)
        
        self.exact_X = (self.Lambda * self.latent).T
        
        self.X =  self.exact_X + torch.normal(0., noise_std, size = (n_obs, n_features)) 
        

# %% ../nbs/02_Imputation.ipynb 45
class GPFAImputation:
    def __init__(
        self,
        data: pd.DataFrame , #observed data with missing data as NA
    ):
        self.data = data
        self.T = torch.arange(0, len(data), dtype=torch.float32) # time is encoded with a increase of 1
        
        # Training data
        self.train_idx = ~self.data.isna().any(1)
        self.train_data = torch.tensor(self.data[self.train_idx].to_numpy())
        self.train_T = self.T[self.train_idx]
        
        self.learner = GPFALearner(X = self.train_data, T = self.train_T)

        # Prediction data
        self.pred_T = self.T[~self.train_idx]
        self.cond_idx = torch.tensor(~self.data[~self.train_idx].isna().to_numpy().flatten()) # conditional obsevations
        self.cond_obs = torch.tensor(self.data[~self.train_idx].to_numpy().flatten()[self.cond_idx])
        
        
    def impute(self,
               add_time = True, # add column with time?
               tidy = True # tidy data?
               ):
        self.learner.train()
        self.pred = self.learner.predict(self.pred_T, obs = self.cond_obs, idx = self.cond_idx)
        
        if tidy: return self._impute_tidy(add_time)
        else: return self._impute_wide(add_time)
        
        
    def _impute_wide(self, add_time):
        """ Impute in wide format"""
        
        imp_data = self.data.copy()
        for col_idx, col_name in enumerate(imp_data.columns):
            imp_data.loc[~self.train_idx, col_name] = self.pred.mean[:, col_idx].numpy()
            imp_data.loc[~self.train_idx, col_name + "_std"] = self.pred.std[:, col_idx].numpy()
        
        idx_vars = []
        if add_time:
            imp_data["time"] = self.T
            idx_vars.append("time")
        
        return imp_data 
    
    def _impute_tidy(self, add_time):
        """ transform the pred output into a tidy dataframe suitable for plotting"""
        feature_names = self.data.columns

        pred_mean = pd.DataFrame(self.pred.mean, columns = feature_names).assign(time = self.pred_T).melt("time", value_name="mean")
        pred_std = pd.DataFrame(self.pred.std, columns = feature_names).assign(time = self.pred_T).melt("time", value_name="std")
        
        pred = pd.merge(pred_mean, pred_std, on=['time', 'variable'])  
        
        train_data = self.data[self.train_idx].assign(time = self.train_T).melt("time", value_name = "mean")
               
        pred = pd.concat((train_data, pred))
        
        self.pred_tidy = pred 
        return pred 
    
